name: PR Status Monitoring

on:
  pull_request:
    types: [opened, synchronize, reopened]
  pull_request_review:
    types: [submitted]
  check_suite:
    types: [completed]
  schedule:
    # Check for stale PRs every 6 hours
    - cron: '0 */6 * * *'
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  monitor-pr-status:
    runs-on: ubuntu-latest
    
    steps:
      - name: Monitor PR Health
        uses: actions/github-script@v7
        with:
          script: |
            // Get all open PRs
            const prs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });
            
            const issues = [];
            const needsAttention = [];
            
            for (const pr of prs.data) {
              // Check CI status
              const checks = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });
              
              const failingChecks = checks.data.check_runs
                .filter(check => check.conclusion === 'failure');
              
              if (failingChecks.length > 0) {
                issues.push(`PR #${pr.number} has ${failingChecks.length} failing CI checks`);
                needsAttention.push({
                  pr: pr.number,
                  issue: 'failing-ci',
                  priority: 'urgent'
                });
              }
              
              // Check if PR needs rebase
              const prDetail = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });
              
              if (prDetail.data.mergeable === false) {
                issues.push(`PR #${pr.number} needs rebase`);
                needsAttention.push({
                  pr: pr.number,
                  issue: 'needs-rebase',
                  priority: 'high'
                });
              }
              
              // Check for unresolved reviews
              const reviews = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });
              
              const hasRequestedChanges = reviews.data
                .some(review => review.state === 'CHANGES_REQUESTED');
              
              if (hasRequestedChanges) {
                issues.push(`PR #${pr.number} has unresolved review comments`);
                needsAttention.push({
                  pr: pr.number,
                  issue: 'changes-requested',
                  priority: 'high'
                });
              }
            }
            
            // If we found issues, create or update a status issue
            if (issues.length > 0) {
              const statusIssues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: 'pr-status-alert',
                state: 'open'
              });
              
              const body = `## PR Status Alert
              
              The following PRs need attention:
              
              ${issues.map(issue => `- ${issue}`).join('\n')}
              
              ${needsAttention
                .filter(item => item.priority === 'urgent')
                .map(item => `\n### URGENT: PR #${item.pr}\n@claude, please address the ${item.issue} in PR #${item.pr}`)
                .join('\n')}
              
              ---
              Generated at: ${new Date().toISOString()}`;
              
              if (statusIssues.data.length > 0) {
                // Update existing issue
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: statusIssues.data[0].number,
                  body: body
                });
              } else {
                // Create new issue
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: 'ðŸš¨ PR Status Alert',
                  body: body,
                  labels: ['pr-status-alert']
                });
              }
            } else {
              // Close any open status issues if everything is healthy
              const statusIssues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: 'pr-status-alert',
                state: 'open'
              });
              
              for (const issue of statusIssues.data) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  state: 'closed',
                  state_reason: 'completed'
                });
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: 'All PRs are healthy! Closing this alert.'
                });
              }
            }